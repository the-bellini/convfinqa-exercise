import logging

from bs4 import BeautifulSoup
from convfinqa.utils import chat_completion, predict_entities

from .utils.prompts import calculations_prompt, questions_prompt, check_question_prompt

# Configure logging
logging.basicConfig(
    level=logging.INFO,  # Set the logging level (DEBUG, INFO, WARNING, ERROR, CRITICAL)
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",  # Customize the format
    datefmt="%Y-%m-%d %H:%M:%S",  # Set the date format
    handlers=[
        logging.FileHandler("app.log"),  # Log to a file
        logging.StreamHandler(),  # Log to console
    ],
)

# Create a logger
logger = logging.getLogger(__name__)


def generate_questions(question: str, summary: str, amt_table: str, data: dict) -> str:
    """
    Generates follow-up finance-related questions based on a given question and summary.
    The questions are double-checked and altered by check_question_prompt.

    Args:
        question (str): The primary question related to financial data.
        summary (str): A summary of the financial information.

    Returns:
        str: A string containing the generated follow-up questions.
    """
    # Filter doc based on question
    filtered_chunks = filter_chunks(
        generated_questions="", question=question, data=data
    )

    logger.info(filtered_chunks)

    # Prompts
    system_prompt = "You are a finance expert. You are particularly adept at reading financial data."
    for i in range(0, 2):
        user_prompt = (
            questions_prompt(
                question=question,
                summary=summary,
                amt_table=amt_table,
                filtered_chunks=filtered_chunks,
            )
            if i == 0
            else check_question_prompt(
                question=question, generated_questions=generated_questions
            )
        )

        # Get generated follow-up questions
        generated_questions = chat_completion(
            system_prompt=system_prompt, user_prompt=user_prompt
        )

    logger.info(f"Generated questions: {generated_questions}")

    return generated_questions


def filter_chunks(generated_questions: str, question: str, data: dict):
    """
    Filters document chunks based on the presence of predicted entities.

    This function predicts entities from the concatenated `question` and
    `generated_questions` strings. It then filters and returns the chunks
    from the provided data that contain any of the predicted entities.

    Args:
        generated_questions (str): The string containing generated follow-up questions.
        question (str): The primary question related to the document.
        data (dict): A dictionary containing document chunks and their associated entity labels.

    Returns:
        list: A list of filtered chunks (strings) that match the predicted entities.
    """
    entities = predict_entities(question + generated_questions)

    logger.info(entities)

    filtered_chunks = [
        chunk["chunk"]
        for chunk in data["entity_chunks"]
        if any(item in entities for item in chunk["labels"])
    ]

    return filtered_chunks


def generate_calculations(
    generated_questions: str, question: str, amt_table: str, data: dict
) -> str:
    """
    Generates financial calculations in Python based on generated questions and a data table.

    Args:
        generated_questions (str): A string of follow-up questions generated by the system.
        question (str): The primary question related to financial data.
        amt_table (str): The data table containing financial information for the calculations.

    Returns:
        str: A string containing the output of financial calculations or a relevant error message.
    """
    # Filter doc based on generated q's and question
    filtered_chunks = filter_chunks(
        generated_questions=generated_questions, question=question, data=data
    )

    # Prompts
    system_prompt = "You are a finance expert. You are particularly adept at writing financial calculations in python."
    user_prompt = calculations_prompt(
        question=question,
        generated_questions=generated_questions,
        amt_table=amt_table,
        filtered_chunks=filtered_chunks,
    )

    # Retrieve content
    content = chat_completion(system_prompt=system_prompt, user_prompt=user_prompt)
    logger.info(f"Calculations: {str(content)}")

    try:
        # Parse the content with BeautifulSoup
        soup = BeautifulSoup(content, "xml")

        # Log the parsed content for debugging
        logger.debug(f"Parsed XML:\n{soup.prettify()}")

        # Find the answer tag
        answer_tag = soup.find("answer")

        if answer_tag is not None:
            return answer_tag.text.strip()  # Return the text inside <answer> tag
        else:
            logger.warning("No <answer> tag found in the response.")
            return "No valid calculations could be generated."

    except Exception as e:
        logger.error(f"Unexpected error during calculation generation: {e}")
        return "Error: An unexpected issue occurred while generating calculations."


def execute_query_processing(question: str, data: dict) -> str:
    """
    Processes the query by generating follow-up questions and performing financial calculations.

    Args:
        data (dict): A dictionary containing the primary question, summary, and amount table.

    Returns:
        str: The final output containing the financial calculations.
    """
    summary = data["summary"]
    amt_table = data["amt_table"]

    generated_questions = generate_questions(
        question=question, summary=summary, amt_table=amt_table, data=data
    )
    calculations = generate_calculations(
        generated_questions=generated_questions,
        question=question,
        amt_table=amt_table,
        data=data,
    )

    return calculations
